---
eip: <to be assigned>
title: <EIP title>
author: Kazuaki Ishiguro (@kazuakiishiguro), Dan Lipart (@danlipert)
discussions-to: <TBA>
status: Draft
type: Standards Track
category: ERC
created: 2019-12-31
requires: 165, 173, 196, 197
# replaces (*optional): <EIP number(s)>
---

## Simple Summary

Propose a standard interface for zk-SNARKs based on-chain voting contract.

## Abstract

Proposal of interface for voting using zk-SNARKs. This standard provides token transfer in basic anonymous voting using zk-SNARK. A protocol that meets this minimum requirement is named CREAM (Confidential Reliable Ethereum Anonymous Mixer) protocol because of its anonymity and the characteristics of the contract method.

## Motivation

Underlying this proposal, inspired by Vitalik's [Minimal Mixer design](https://hackmd.io/@HWeNw8hNRimMm2m2GH56Cw/rJj9hEJTN?type=view) proposal, the use of dapps [tornado](https://tornado.cash/) that implements them is expected to increase the use cases further developed in the future.
Additional use of this implementation is to ensure transparency in DAO governance and to achieve voting with zero knowledge proof.

## Specification

Much of the basic interface was taken from [tornado](https://tornado.cash/), which is already deployed on the ethereum mainnet. The main methods are as follows:

### Draft methods

#### constructor

Constructor requires `_verifier` contract address which is generated by third party zk-SNARK tool(*), amount of `_denomination`, `_merkleTreeHeight` which is the size of Merkle tree and an array of `_recipients` address. The only difference between other anonymous mixer dapps is the requirement of `_recipients` address to be able to vote clearly.

```js
constructor(
    IVerifier _verifier,
    uint256 _denomination,
    uint32 _merkleTreeHeight,
    address[] memory _recipients
) MerkleTreeWithHistory(_merkleTreeHeight) public {
    require(_denomination > 0, "denomination should be greater than 0");
    require(_recipients.length > 0, "recipients number be more than one");
    // other settings and methods
    // ...
}
```

#### deposit

Deposit method requires one argument `_commitment` which generated on off-chain. Also requires to send exact `msg.value` which is defined by constructor.

```js
function deposit(bytes32 _commitment) external payable {
    require(!commitments[_commitment], "Already submitted");
    require(msg.value == denomination, "Please send ETH along with transaction");
    _insert(_commitment);
    // other settings and methods
    // ...
}
```

#### withdraw

Withdraw method requires `_proof`, `_root` and `_nullifierHash` which are calculated on of-chain. The `_recipient` address will be the address of the token receiver. There are also some optional arguments can be passed if you would like to use `_relayer` and `_fee` which goes to relayer. To prevent to vote (send token) to non-authorized recipients, `isRecipient` check is required.

```js
function withdraw(
    bytes calldata _proof,
    bytes32 _root,
    bytes32 _nullifierHash,
    address payable _recipient,
    address payable _relayer, // optional
    uint256 _fee // optional
) external payable {
    // somre require methods
    // ...
    require(verifier.verifyProof(
        _proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _fee]), "Invalid withdraw proof");
    require(isRecipient(_recipient), "Recipient do not exist");
    nullifierHashes[_nullifierHash] = true;
    // other settings and methods
    // ...
}
```

#### recipient

For safety, calling `setRecipients` is required when the contract owner deploys a new contract with `constructor()` method. This method can be done with `onlyOwner` is a good start.

```js
mapping(address => bool) Recipients;

function setRecipients(
    address[] memory _recipients
) internal onlyOwner {
    for (uint i; i < _recipients.length; i++) {
        Recipients[_recipients[i]] = true;
    }
}

function isRecipient(
    address _recipient
) internal view returns(bool) {
    return Recipients[_recipient];
}
```

*NOTE for recipient specification.*

The recipient address can be `contract.address` or `externally owned account (EOA)` depends on usecase. A point to be noted in the implementation is to accept only the dominance from the registered relayer in the case of the contract address so that no other account can remit to the recipient, and in the case of EOA, the token used for the dominance is ERC- 20 is required.

```js
// TBA
```

#### verifier

The Verifier contract can be updated by contract `owner`.

```js
function updateVerifier(
    address _newVerifier
) external onlyOwner {
    verifier = IVerifier(_newVerifier);
}
```

##### verifier interface

The contract SHOULD pass `IVerifier` address when the contract owner deploys a new contract with `constructor()` method. `IVerifier` contract contains `verifyProof` method with two arguments: `_proof` and `_input` which is an array of `withdraw` method's arguments except `proof`.

```js
contract IVerifier {
    function verifyProof(bytes memory _proof, uint256[5] memory _input) public returns(bool);
}
```

### hasher

```js
library Hasher {
    function MiMCSponge(uint256 in_xL, uint256 in_xR, uint256 in_k) public pure returns (uint256 xL, uint256 xR);
}
```

### merkletree

One of the core methods from MerkleTree contract is `_insert` method, which is called by Cream contract's `deposit` method and SHOULD return tree index.

```js
function _insert(bytes32 _leaf) internal returns(uint32 index) {}
```

## Rationale

TBD

## Backwards Compatibility

This instruction was never used and therefore has no effect on past contracts.

## Test Cases

TBD

## Implementation

An implementation can be found at [CREAM repo](https://github.com/couger-inc/cream/).

### Library

This implementation uses zk-snark following libraries :

* Circuit compiler for zkSNARKs : [circom](https://github.com/iden3/circom)
* Library of basic circuits for circom : [circomlib](https://github.com/iden3/circomlib)
* zk-SNARKs implementation in JavaScript : [snarkjs](https://github.com/iden3/snarkjs)
* A fast zk-SSNARKs proof generator written in native Web Assembly : [websnark](https://github.com/iden3/websnark)

## Related other EIPs

* Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128 : [EIP-196](https://github.com/ethereum/EIPs/blob/ed621645c8f3bc5756492f327cda015f35d9f8da/EIPS/eip-196.md)
* Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128 : [EIP-197](https://github.com/ethereum/EIPs/blob/ed621645c8f3bc5756492f327cda015f35d9f8da/EIPS/eip-197.md)
* Reduce alt_bn128 precompile gas costs : [EIP-1108](https://github.com/ethereum/EIPs/blob/40be4cb868/EIPS/eip-1108.md)
* zk-SNARK Verifier Standard : [EIP1922](https://github.com/ethereum/EIPs/blob/af982f1470624791da334b09d3e4f2e4de5e1265/EIPS/eip-1922.md)
* zk-SNARK Verifier Registry Standard : [EIP-1923](https://github.com/ethereum/EIPs/blob/e8a54cb5e43529207f76f746155fa120dc5e4363/EIPS/eip-1923.md)
* Poll Standard : [EIP-1417](https://github.com/ethereum/EIPs/blob/af982f1470/EIPS/eip-1417.md)

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
