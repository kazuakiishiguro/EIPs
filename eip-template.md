---
eip: <to be assigned>
title: Anonymous and Verifiable On-chain Voting via CREAM: Confidential Reliable Ethereum Anonymous Mixer
author: Kazuaki Ishiguro (@kazuakiishiguro), Dan Lipert (@danlipert) <dan.lipert@consensys.net>
discussions-to: <TBA>
status: Draft
type: Standards Track
category: ERC
created: 2019-12-31
requires: 165, 173, 196, 197
# replaces (*optional): <EIP number(s)>
---

## Simple Summary

Propose a standard interface for a zk-SNARK based on-chain voting contract that provides both anonymity of the voting parties as well as verifiability of the votes.

## Abstract

Proposal of interface for voting using zk-SNARKs. This standard provides a means of token transfer to effect basic anonymous voting using zk-SNARKs. A protocol that meets this minimum requirement is named CREAM (Confidential Reliable Ethereum Anonymous Mixer) protocol because of its anonymity and the characteristics of the contract method.

## Motivation

Underlying this proposal, inspired by Vitalik's [Minimal Mixer design](https://hackmd.io/@HWeNw8hNRimMm2m2GH56Cw/rJj9hEJTN?type=view) proposal, and the use of dapps [tornado](https://tornado.cash/) that implement it, is expected to increase the use cases of this technology for multiple applications in the future.
This implementation ensures transparency and anonymity in both DAO governance as well as real-world traditional poltical voting.

## Specification

Much of the basic interface was taken from [tornado](https://tornado.cash/), which is already deployed on the ethereum mainnet. The main methods are as follows:

### Draft methods

#### constructor

Constructor requires `_verifier` contract address which is generated by the third party zk-SNARK tool(*), amount of `_denomination`, `_merkleTreeHeight` which is the size of Merkle tree and an array of `_recipients` address. The only difference between other anonymous mixer dapps is the requirement of `_recipients` address to be able to vote clearly.

```js
constructor(
    IVerifier _verifier,
    uint256 _denomination,
    uint32 _merkleTreeHeight,
    address[] memory _recipients
) MerkleTreeWithHistory(_merkleTreeHeight) public {
    require(_denomination > 0, "denomination should be greater than 0");
    require(_recipients.length > 0, "recipients number be more than one");
    // other settings and methods
    // ...
}
```

#### deposit

Deposit method requires one argument `_commitment` which is generated on off-chain. Also requires to send exact `msg.value` which is defined by constructor.

```js
function deposit(bytes32 _commitment) external payable {
    require(!commitments[_commitment], "Already submitted");
    require(msg.value == denomination, "Please send ETH along with transaction");
    _insert(_commitment);
    // other settings and methods
    // ...
}
```

#### withdraw

Withdraw method requires `_proof`, `_root` and `_nullifierHash` which are calculated off-chain. The `_recipient` address will be the address of the token receiver. There are also some optional arguments can be passed if you would like to use `_relayer` and `_fee` which goes to relayer. To prevent voting by non-authorized recipients via transfer of the token an `isRecipient` check is required.

```js
function withdraw(
    bytes calldata _proof,
    bytes32 _root,
    bytes32 _nullifierHash,
    address payable _recipient,
    address payable _relayer, // optional
    uint256 _fee // optional
) external payable {
    // some require methods
    // ...
    require(verifier.verifyProof(
        _proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _fee]), "Invalid withdraw proof");
    require(isRecipient(_recipient), "Recipient does not exist");
    nullifierHashes[_nullifierHash] = true;
    // other settings and methods
    // ...
}
```

#### recipient

For safety, calling `setRecipients` is required when the contract owner deploys a new contract with the `constructor()` method. This method can be done with the `onlyOwner` modifier.

```js
mapping(address => bool) Recipients;

function setRecipients(
    address[] memory _recipients
) internal onlyOwner {
    for (uint i; i < _recipients.length; i++) {
        Recipients[_recipients[i]] = true;
    }
}

function isRecipient(
    address _recipient
) internal view returns(bool) {
    return Recipients[_recipient];
}
```

*NOTE for recipient specification.*

The recipient address can be `contract.address` or an `externally owned account (EOA)` depending on the use-case. A point to be noted in the implementation is to accept only the dominance from the registered relayer in the case of the contract address so that no other account can remit to the recipient, and in the case of EOA, the token used for the dominance is ERC- 20 is required.

```js
// TBA
```

#### verifier

The Verifier contract can be updated by contract `owner`.

```js
function updateVerifier(
    address _newVerifier
) external onlyOwner {
    verifier = IVerifier(_newVerifier);
}
```

##### verifier interface

The contract SHOULD pass `IVerifier` address when the contract owner deploys a new contract with `constructor()` method. `IVerifier` contract contains `verifyProof` method with two arguments: `_proof` and `_input` which is an array of `withdraw` method's arguments except `proof`.

```js
contract IVerifier {
    function verifyProof(bytes memory _proof, uint256[5] memory _input) public returns(bool);
}
```

### hasher

```js
library Hasher {
    function MiMCSponge(uint256 in_xL, uint256 in_xR, uint256 in_k) public pure returns (uint256 xL, uint256 xR);
}
```

### merkletree

One of the core methods from MerkleTree contract is `_insert` method, which is called by CREAM contract's `deposit` method and SHOULD return tree index.

```js
function _insert(bytes32 _leaf) internal returns(uint32 index) {}
```

## Rationale

TBD

## Backwards Compatibility

This code has not previously been used and therefore has no effect on past contracts.

## Test Cases

TBD

## Implementation

An implementation can be found at [CREAM repo](https://github.com/couger-inc/cream/).

### Library

This implementation uses zk-snark following libraries :

* Circuit compiler for zkSNARKs : [circom](https://github.com/iden3/circom)
* Library of basic circuits for circom : [circomlib](https://github.com/iden3/circomlib)
* zk-SNARKs implementation in JavaScript : [snarkjs](https://github.com/iden3/snarkjs)
* A fast zk-SSNARKs proof generator written in native Web Assembly : [websnark](https://github.com/iden3/websnark)

## Related other EIPs

* Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128 : [EIP-196](https://github.com/ethereum/EIPs/blob/ed621645c8f3bc5756492f327cda015f35d9f8da/EIPS/eip-196.md)
* Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128 : [EIP-197](https://github.com/ethereum/EIPs/blob/ed621645c8f3bc5756492f327cda015f35d9f8da/EIPS/eip-197.md)
* Reduce alt_bn128 precompile gas costs : [EIP-1108](https://github.com/ethereum/EIPs/blob/40be4cb868/EIPS/eip-1108.md)
* zk-SNARK Verifier Standard : [EIP1922](https://github.com/ethereum/EIPs/blob/af982f1470624791da334b09d3e4f2e4de5e1265/EIPS/eip-1922.md)
* zk-SNARK Verifier Registry Standard : [EIP-1923](https://github.com/ethereum/EIPs/blob/e8a54cb5e43529207f76f746155fa120dc5e4363/EIPS/eip-1923.md)
* Poll Standard : [EIP-1417](https://github.com/ethereum/EIPs/blob/af982f1470/EIPS/eip-1417.md)

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
